<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>ATTAK Docs</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #272822;
  background-color: #f92672;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #75715e;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #f8f8f2;
}
.highlight .p, .highlight .pi {
  color: #f8f8f2;
}
.highlight .gi {
  color: #a6e22e;
}
.highlight .gd {
  color: #f92672;
}
.highlight .gh {
  color: #66d9ef;
  background-color: #272822;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #ae81ff;
}
.highlight .kc {
  color: #fd971f;
}
.highlight .kt {
  color: #fd971f;
}
.highlight .kd {
  color: #fd971f;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #a6e22e;
}
.highlight .sr {
  color: #a1efe4;
}
.highlight .si {
  color: #cc6633;
}
.highlight .se {
  color: #cc6633;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #66d9ef;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #a6e22e;
}
.highlight .ss {
  color: #a6e22e;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" alt="Logo" />
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='#'>Get update notifications</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>Welcome to attak! We aim to create the simplest and most powerful way to build high-scale distributed realtime computation topologies. We provide tools to assist in prototyping, development, deployment, and production monitoring.</p>

<h2 id="a-distrubted-what">A Distrubted What?</h2>

<p>When processing streaming data, it can often be useful to break tasks out into separate microservices. Those microservices usually need to send data to eachother, and good practice dictates some kind of fault-tolerant queue system is used.</p>

<p>A topology is what we call everything together - the set of all data processing microservices (we call them &ldquo;processors&rdquo;) and data queues (&ldquo;streams&rdquo;).</p>

<h2 id="why-use-attak">Why use ATTAK</h2>

<p>ATTAK has several advantages over existing frameworks like Apache Storm</p>

<p><strong><em>Speed and Simplicity</em></strong></p>

<p>It&rsquo;s just node (or whatever shell processes you want to call)</p>

<p>Running a local Storm topology can take minutes (Storm has to compile an uber-jar and then boot up the JVM and bolt/spout processes). Simulating an <strong>attak</strong> topology takes seconds. That makes a huge difference in the code -&gt; run -&gt; debug cycle</p>

<p>AWS Lambdas, Kinesis Streams, Google Cloud Functions, PubSub, etc. all have very well established logging and debugging capabilities. Handling producton issues is much easier because ATTAK is built on these proven building blocks</p>

<p><strong><em>Price of Prototype</em></strong></p>

<p>Apache Storm requires a lot of system resources to run, meaning setting up a prototype/qa/staging deploy can be expensive. <a href="https://github.com/nathanmarz/storm-deploy">This popular example</a> uses 4 m1-large EC2 instances. Other common deployments (DCOS for example) use even more.</p>

<p>ATTAK&rsquo;s auto-scaling building blocks are pay-per-request, so idle topologies cost nothing.</p>

<p><strong><em>Maintenance</em></strong></p>

<p>Auto-scaling components mean there are no servers to be juggled, no CPUs or disks to monitor, no logs to rotate, etc. Everything just works&hellip;and did we mention it&rsquo;s cheaper?</p>

<h1 id="getting-started">Getting Started</h1>

<h3 id="prerequisites">Prerequisites</h3>

<ul>
<li><a href="https://nodejs.org/en/download/">node.js</a></li>
</ul>

<h2 id="installation">Installation</h2>
<pre class="highlight plaintext"><code>npm install -g attak
</code></pre>
<p><code class="prettyprint">npm install -g attak</code></p>

<h2 id="hello-world-topology">Hello World Topology</h2>

<p>We&rsquo;ve setup an extremely basic example of an ATTAK topology.</p>

<h3 id="create-new-project">Create new project</h3>

<h2 id="motivation">Motivation</h2>

<p>Serverless functions are awesome because single-purpose microservices are a great way to organize code. However, real-world use cases often require multiple microservices, and communicating between them in a fault tolerant way takes some thought.</p>

<p>Existing solutions like Apache Storm use queues to stream data between functions, but require special hosting which can be expensive and cumbersome. They&rsquo;re also mostly focused on Java and JVM technologies.</p>

<p><strong>attak</strong> is built to combine existing, proven products (Lambdas, Kinesis Streams, Kubernetes, PubSub, etc.) to create a better solution using more modern technologies.</p>

<h2 id="why-use-attak">Why use <strong>attak</strong>?</h2>

<p><strong>attak</strong> has several advantages:</p>

<p><strong><em>Speed and Simplicity</em></strong></p>

<p>It&rsquo;s just node (or whatever shell processes you want to call)</p>

<p>Running a local Storm topology can take several minutes (you have to compile an uber-jar and then boot up the JVM and all the bolt/spout processes). Simulating an <strong>attak</strong> topology takes seconds.</p>

<p>Serverless functions and queuing systems have existing error handling solutions, so any existing debugging infrastructure will still work. For instance, logs from AWS Lambdas are automatically sent to CloudWatch, where they can be easly monitored.</p>

<p><strong><em>Price</em></strong></p>

<p>Apache Storm requires several dedicated servers to run. <a href="https://github.com/nathanmarz/storm-deploy">this popular example</a> uses 4 m1-large EC2 instances which costs something like $500/mo even when inactive.</p>

<p><strong>attak</strong> uses auto-scaling building blocks, so it mostly sits idle when not in use. An inactive topology will likely cost under $10/mo, and will be significantly cheaper at scale also.</p>

<p><strong><em>Maintenance</em></strong></p>

<p>Auto-scaling components mean there are no servers to be juggled, no CPUs or disks to monitor, no logs to rotate, etc. Everything just works&hellip;and did we mention it&rsquo;s cheaper?</p>

<h2 id="usage">Usage</h2>

<p>In order to get a topology running you need to build a topology file and define one or more processors.</p>

<h3 id="topology-file">Topology file</h3>

<p>An attak topology is simply a javascript or raw JSON file that we <code class="prettyprint">require</code>. At its core, a topology is a description of one or more processors and the connections between them. Here&rsquo;s an example of a very simple topology.</p>
<pre class="highlight javascript"><code><span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="s1">'attak-example'</span><span class="p">,</span>                          <span class="c1">// a topology name is required</span>
  <span class="na">processors</span><span class="p">:</span> <span class="p">{</span>                                   <span class="c1">// declare processors</span>
    <span class="na">reverse</span><span class="p">:</span> <span class="s1">'./processors/reverse'</span><span class="p">,</span>
    <span class="na">hello_world_spout</span><span class="p">:</span> <span class="s1">'./processors/hello_world'</span>
  <span class="p">},</span>
  <span class="na">streams</span><span class="p">:</span> <span class="p">[</span>                                      <span class="c1">// declare processor connections</span>
    <span class="p">{</span>
      <span class="na">to</span><span class="p">:</span> <span class="s1">'reverse'</span><span class="p">,</span>                              <span class="c1">// simple connection example</span>
      <span class="na">from</span><span class="p">:</span> <span class="s1">'hello_world_spout'</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span>
</code></pre>
<h3 id="processors">Processors</h3>

<p><strong>attak</strong> has a single concept for all data processing units: processors. In the abstract a processor is triggered in response to some event. The processor can access event data if any, and can emit any number of new events. Here&rsquo;s an example processor:</p>
<pre class="highlight javascript"><code><span class="nx">exports</span><span class="p">.</span><span class="nx">handler</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">context</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span>                             <span class="c1">// prints 'hello world'</span>
  <span class="nx">reversed</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">''</span><span class="p">).</span><span class="nx">reverse</span><span class="p">().</span><span class="nx">join</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>   <span class="c1">// process event data (reverse it)</span>
  <span class="nx">context</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="s1">'reversed strings'</span><span class="p">,</span> <span class="nx">reversed</span><span class="p">)</span>      <span class="c1">// emit a "reversed strings" event</span>
  <span class="nx">callback</span><span class="p">()</span>                                      <span class="c1">// close up shop</span>
<span class="p">}</span>
</code></pre>
<h3 id="simulate-a-topology">Simulate a topology</h3>

<p><code class="prettyprint">attak simulate</code></p>

<p>Simulate pulls in data (from <code class="prettyprint">./input.json</code> by default) and feeds it through the specified processors. Input data has the following format:</p>
<pre class="highlight json"><code><span class="p">{</span><span class="w">
    </span><span class="nt">"processor_name"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nt">"the_data"</span><span class="p">:</span><span class="w"> </span><span class="s2">"you want to be sent in"</span><span class="p">},</span><span class="w">
    </span><span class="nt">"other_processor"</span><span class="p">:</span><span class="w"> </span><span class="s2">"string data is fine"</span><span class="p">,</span><span class="w">
</span><span class="err">}</span><span class="w">
</span></code></pre>
<h3 id="deploy-a-topology">Deploy a topology</h3>

<p><code class="prettyprint">attak deploy</code></p>

<p>Assembles and deploys a series of functions pre-baked with topology information, so event emissions go directly from function to stream to function.</p>

<h3 id="trigger-a-live-topology">Trigger a live topology</h3>

<p><code class="prettyprint">attak trigger</code></p>

<p>Pulls in data (from <code class="prettyprint">./input.json</code> by default) and sends it to a live topology instance</p>

<h3 id="roadmap">Roadmap</h3>

<h4 id="features">Features</h4>

<ul>
<li><p>Create basic topologies</p>

<ul>
<li>processors √</li>
<li>streams (with topics) √</li>
</ul></li>
<li><p>Debugging</p>

<ul>
<li>simulate topology locally √</li>
<li>trigger live topology √</li>
<li>collect topology logs √</li>
</ul></li>
<li><p>Topology Flow Control</p>

<ul>
<li>managed parallelization (split/join streams)</li>
<li>stream aggregation</li>
</ul></li>
</ul>

<h4 id="platforms">Platforms</h4>

<p><em>tldr: AWS first</em></p>

<ol>
<li><p>AWS Support</p>

<ul>
<li><a href="https://aws.amazon.com/lambda">Lambda</a>/<a href="https://aws.amazon.com/kinesis">Kinesis</a> topologies √</li>
<li>CloudWatch logs √</li>
</ul></li>
<li><p>Google Cloud Support</p>

<ul>
<li><a href="https://cloud.google.com/functions/">Cloud Functions</a>/<a href="https://cloud.google.com/pubsub">PubSub</a> topologies</li>
<li>StackDriver? logs</li>
</ul></li>
</ol>

<p>We intend for full google cloud support, but we won&rsquo;t focus on it until Cloud Functions gets out of alpha. Theoretically that will happen <a href="https://github.com/apex/apex/issues/232#issuecomment-218246926">&ldquo;soon&rdquo;</a></p>

<ol>
<li>Others? Open an issue! We&rsquo;d love to hear about your use case.</li>
</ol>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
